##########################################################
##########################################################
#
# Example Modsecurity audit log ingestor
# configuration for Logstash
#
# @author bitsofinfo.g[at]gmail.com
# built/tested w logstash v1.3.x line
#
#
# @see http://logstash.net/
# @see https://github.com/SpiderLabs/ModSecurity/wiki/ModSecurity-2-Data-Formats
# @see http://bitsofinfo.wordpress.com/2013/09/19/logstash-for-modsecurity-audit-logs/
#
# @license http://www.apache.org/licenses/LICENSE-2.0
#
# @notes NOTE: this is not perfect and I am no Ruby expert
#        however this worked when processing quite a bit of
#        high volume mod-sec logs with lots of different
#        variations in what A-K sections were and were not
#        present. At a minimum its a good starting point
#        to start tackling a complex log format.
#
# Be careful w/ the custom ruby filter blocks and be aware
# of https://logstash.jira.com/browse/LOGSTASH-1375
#
# This config file for whatever reason will not run
# if you try to add the "-- web" option onto the logstash
# flat jar. This has been reported to the developers.
# Recommend you run this without the "-- web" option and just
# hook up Kibana separately.
#
# Enable the "-v" verbose option when starting logstash
# to aid in debugging things. Disable the "-v" option
# when running in real/non-debug environment
#
#
##########################################################
##########################################################
input {

  stdin {
    type => "mod_security_alert"
    codec => multiline {
      pattern => "^--[a-fA-F0-9]{8}-Z--$"
      negate => true
      what => next
    }
  }

}
input {
  file {
    # IMPORTANT! set this correctly to the charset
    # that your server writes these log files in
    path => "/var/log/apache2/modsec_alert.log"
      type => "mod_security_alert"

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # merge all modsec events for a given entity into the same event.
    # so essentially the modsec -Z marker is used as the splitter
    # which is the end of each modsec logical event in the logfile
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    codec => multiline {
      charset => "US-ASCII"
      pattern => "^--[a-fA-F0-9]{8}-Z--$"
      negate => true
      what => next
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Due to the complexity of the collapsed single string
    # we get from multiline and the variance of exactly
    # which modsec sections (A-K) may or may not be in each
    # log entry, we run some custom ruby code that will
    # split on each modsec "section" and store each found in
    # new fields named "rawSection[A-K]" as appropriate, the value
    # of each of these fields contains the raw un-parsed data
    # from that modsec section. Sections that are non-existant
    # will not have a key in "fields"
    #
    # A bit long and crazy yes, but after spending many hours
    # just doing this w/ grok patterns, this ended up being the
    # most reliable way to break up this in-consistent format into
    # more usable blocks
    #
    # @see https://github.com/SpiderLabs/ModSecurity/wiki/ModSecurity-2-Data-Formats
    #
    # READ the above to get a good understanding of the sections
    # and which ones can actively contain data depending on your modsec
    # version and environment!
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    ruby {
      code => "
          if !event.get('message').nil?
              modSecSectionData = event.get('message').split(/(?:--[a-fA-F0-9]{8}-([A-Z])--)/)
              modSecSectionData.shift
              for i in 0..((modSecSectionData.length-1)/2)
                  sectionName = 'rawSection'.concat(modSecSectionData.shift)
                  sectionData = modSecSectionData.shift
                  sectionName = sectionName.strip
                  if !sectionData.nil?
                      sectionData = sectionData.strip
                  end
                  event.set(sectionName, sectionData)
              end
          end
        "
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out fields from Section A (general event basics)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    grok {
      match => {
        "rawSectionA" => "\[(?<modsec_timestamp>%{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} [-\+]{1,2}%{INT})\] %{DATA:uniqueId} %{IP:sourceIp} %{INT:sourcePort} %{IP:destIp} %{INT:destPort}"
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out fields from Section B (request related line 1)
    # note line one could be garbage OR adhere to the
    # httpMethod [space] uri [space] protocol pattern
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # if a legit line... normal http request
    if [rawSectionB] =~ /.+/ {
      grok {
        match => {
          "rawSectionB" => [  "(?m)^%{DATA:httpMethod}\s(?<requestedUri>\S+)\s(?<incomingProtocol>[^\n]+)(?:\n(?<raw_requestHeaders>.+)?)?$",
                              "(?<httpMethod>^(.*)$)" ]
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Convert raw request headers into a key/value
    # pair map
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [raw_requestHeaders] =~ /.+/ {
      kv {
        source => "raw_requestHeaders"
        field_split => "\n"
        value_split => ":"
        target => "requestHeaders"
      }


      # trim leading/trailing hack  @see https://logstash.jira.com/browse/LOGSTASH-1369
      ruby {
        code => "
            requestHeaders = event.get('requestHeaders').to_hash
            requestHeaders.each { |k, v|
              if !v.nil? and v.is_a? String
                requestHeaders[k] = v.strip
              end
            }
          "
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Example of looking for a specific Cookie and promoting
    # it to a first class field
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [raw_requestHeaders] =~ /Cookie/ and [raw_requestHeaders] =~ /myCookie=.+\b/ {

      grok {
        match => {
          "raw_requestHeaders" => "(?<myCookie>myCookie[^; \s]+)"
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Promote real request IP to a field if it exists
    # in the request headers section
    #
    # NOTE this is an example of promoting a custom header to a first
    # class field that might be set by a app firewall or other
    # upstream proxy
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [raw_requestHeaders] =~ /X-Forwarded-For:/ {

      grok {
        match => {
          "raw_requestHeaders" => "X-Forwarded-For: %{IPORHOST:XForwardedFor}"
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Example of splitting all Cookies from the requestHeader Cookie
    # and promoting it to a first class field
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [requestHeaders][Cookie] =~ /.+/ {
        kv {
            source => "[requestHeaders][Cookie]"
            field_split => "; "
            value_split => "="
            target => "requestCookies"
        }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out fields from Section C (post data)
    # this is not always present
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionC] =~ /.+/ {
      mutate {
          add_field => { "requestBody" => "%{rawSectionC}" }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section D (intended response headers)
    # this section is NOT IMPLEMENTED by ModSecurity
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    #if [rawSectionD] =~ /.+/ {
    #  # you can deal w/ this if you want to here...
    #}
  }
}
filter {
  if [type] == "mod_security_alert" {
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section E (intended response data)
    # this is not always present
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionE] =~ /.+/ {
      # you can deal w/ this if you want to here...
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out server protocol/HTTP status from Section F (response related, line 1)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionF] =~ /.+/ {

      grok {
        match => {
          "rawSectionF" => "(?m)^(?<serverProtocol>.+?)\s(?<responseStatus>[^\n]+)(\n(?<raw_responseHeaders>.+)?)?$"
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out response headers from Section F (response headers, lines 2+)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # only if the server responded...WITH headers...
    if [rawSectionF] =~ /(.+?)\s(.+)\n{1}/ {

      grok {
        match => {
          "rawSectionF" => ".+?\n(?m)(?<raw_responseHeaders>.+)"
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Convert raw response headers into a key/value
    # pair map
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [raw_responseHeaders] =~ /.+/ {
      kv {
        source => "raw_responseHeaders"
        field_split => "\n"
        value_split => ":"
        target => "responseHeaders"
      }

      # trim leading/trailing hack  @see https://logstash.jira.com/browse/LOGSTASH-1369
      ruby {
        code => "
            responseHeaders = event.get('responseHeaders').to_hash
            responseHeaders.each { |k, v|
              if !v.nil? and v.is_a? String
                responseHeaders[k] = v.strip
              end
            }
          "
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section G (response body)
    # this section is NOT IMPLEMENTED by ModSecurity
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    #if [rawSectionG] =~ /.+/ {
    #  # you can deal w/ this if you want to here...
    #}
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Explode all "Messages" from sectionH to first
    # class objects w/ properties and store in an array
    # called "auditLogTrailerMessages"
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionH] =~ /.+/ {

      # build the auditlog trailer messages
      ruby {
        code => "
            def extractVal(pattern, fromString, storeResultIn, underKeyName, multiValues=false)
              if multiValues
                result = fromString.scan(pattern)
                if !result.empty?
                  storeResultIn[underKeyName] = result.flatten
                end
              else
                result = pattern.match(fromString)
                if !result.nil?
                  storeResultIn[underKeyName] = result[1]
                end
              end
            end

            auditLogTrailerMessages = Array.new()
            trailer_array = event.get('rawSectionH').split(/\n/)
            trailer_array.each do |entry|
              if entry.match(/^Message: /)
                msg = Hash.new()
                extractVal(/Message: (.+)\s($|(\s*\[file))/, entry, msg, 'info')
                extractVal(/\[file \"(.*?)\"\]/, entry, msg, 'file')
                extractVal(/\[line \"(.*?)\"\]/, entry, msg, 'line')
                extractVal(/\[id \"(.*?)\"\]/, entry, msg, 'id')
                extractVal(/\[msg \"(.*?)\"\]/, entry, msg, 'msg')
                extractVal(/\[severity \"(.*?)\"\]/, entry, msg, 'severity')
                extractVal(/\[data \"(.*?)\"\]/, entry, msg, 'data')
                extractVal(/\[tag \"(.*?)\"\]/, entry, msg, 'tag')
                auditLogTrailerMessages.push(msg)
              end
            end

            event.set('auditLogTrailerMessages', auditLogTrailerMessages)
          "
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Convert section H into a key/value
    # pair map called "auditLogTrailer"
    # delete the 'Message' sub-key and replace with 'auditLogTrailerMessages'
    # built in the previous section under key 'messages', then
    # delete auditLogTrailerMessages
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionH] =~ /.+/ {
      # For 2.9.1+ compatibility
      mutate {
        # This works for most things, but if the error has things like REQUEST_HEADERS:Referer in it, it can be problematic.
      # gsub => [ "rawSectionH", 'ModSecurity:', 'ModSecurity' ]
        # Alternately, just drop "Apache-Error:" from rawSectionH.
        gsub => [ "rawSectionH", '^Apache-Error:.*', '' ]
      }
      kv {
        source => "rawSectionH"
        field_split => "\n"
        value_split => ":"
        target => "auditLogTrailer"
      }

      # trim leading/trailing hack  @see https://logstash.jira.com/browse/LOGSTASH-1369
      ruby {
        code => "
            auditLogTrailer = event.get('auditLogTrailer').to_hash
            auditLogTrailerMessages = event.get('auditLogTrailerMessages')
            auditLogTrailer.each { |k, v|
              if !v.nil? and v.is_a? String
                auditLogTrailer[k] = v.strip
              end
            }
            auditLogTrailer.delete('Message')
            auditLogTrailer['messages'] = auditLogTrailerMessages

            event.set('auditLogTrailer', auditLogTrailer)
          "
      }

      mutate {
        remove_field => ['auditLogTrailerMessages']
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Promote raw "stopwatch" in section H
    # to a real date. The value is in microseconds
    # since epoch (convert to seconds) then
    # run through logstashes' routine. The result
    # of this is that the logstash @timestamp is converted
    # to be the modsec stopwatch timestamp value. We
    # also retain the milliseconds and seconds fields
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    grok {
      match => {
        "rawSectionH" => "Stopwatch: %{WORD:event_date_microseconds}"
      }
    }

    mutate {
      convert => [ "event_date_microseconds", "float" ]
    }

    # micro -> milli
    ruby {
      code => "
          event_date_milliseconds = (event.get('event_date_microseconds') / 1000.0)
          event.set('event_date_milliseconds', event_date_milliseconds)
        "
    }

    # milli -> seconds
    ruby {
      code => "
          event_date_seconds = (event.get('event_date_milliseconds') / 1000.0)
          event.set('event_date_seconds', event_date_seconds)
        "
    }

    # NOTE!, this forces the event's @timestamp to be = to the stopwatch value
    date {
      match => [ "event_date_seconds", "UNIX" ]
      timezone => "GMT"
    }

    # a second copy of a iso8601 date
    ruby {
      code => "
          event.set('event_timestamp', (Time.at(event.get('event_date_seconds')).gmtime).iso8601(3))
        "
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Create a new field for the real requestor
    # ip address containing the GEOIP info
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    geoip {
      # does need XForwardedFor from 2029_filter_section_b_example_header_X-Forwarded-For.conf
      source => "XForwardedFor"
      target => "XForwardedFor-GEOIP"
    }

    geoip {
      source => "sourceIP"
      target => "sourceIP-GEOIP"
    }

    # Optional, if not fixed: massage values to UTF-8... hack  @see https://logstash.jira.com/browse/LOGSTASH-1372
    # convert Strings to UTF-8, leave as-is otherwise
    #ruby {
    #  code => "
    #      geoip = event.get('XForwardedFor-GEOIP').to_hash
    #      if !geoip.nil?
    #        newgeoip = Hash.new()
    #        geoip.each do |key,value|
    #          if !value.nil? and value.is_a? String
    #            newgeoip[key] = value.encode('UTF-8')
    #          else
    #            newgeoip[key] = value
    #          end
    #        end
    #        event.set('XForwardedFor-GEOIP', newgeoip)
    #      end
    #    "
    #}
  }
}
filter {

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Proceed to extract all distinct "severities"
  # and store them in a top-level "modsecSeverities" array
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  if [rawSectionH] =~ /.+/ {

    # extract distinct severities from the messages built in 2080_filter_section_h_parse_messages_to_auditLogTrailerMessages.conf
    ruby {
      code => "
          modsecSeverities = Set.new
          trailerMsgs = event.get('auditLogTrailer[messages]')
          trailerMsgs.each {|m|
            if m.key?('severity')
              modsecSeverities.add(m['severity'])
            end
          }
          event.set('modsecSeverities', modsecSeverities.to_a)
        "
    }
  }

}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section I (reduced multipart request body)
    # this is not always present
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionI] =~ /.+/ {
      # you can deal w/ this if you want to here...
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section J (multipart files information)
    # this section is NOT IMPLEMENTED by ModSecurity
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    #if [rawSectionJ] =~ /.+/ {
    #  # you can deal w/ this if you want to here...
    #}
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Convert section K into an array
    # and rename it to "matchedRules"
    # also create an array of just the
    # secRuleIds that were located in
    # sectionK
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionK] =~ /.+/ {

      # hack.. @see https://logstash.jira.com/browse/LOGSTASH-1331
      mutate {
        gsub => [ "rawSectionK", "\n", "~" ]
        split => [ "rawSectionK" , "~" ]
      }

      mutate {
        rename => [ "rawSectionK", "matchedRules"]
      }

      ruby {
        code => "
            secRuleIds = Array.new()
            matchedRules_array = event.get('matchedRules').to_hash
            matchedRules_array.each do |entry|
              if entry.match(/^SecRule /) and entry.match(/,id:/)
                secRuleIds.push(/,id:(?<ruleId>\d+)/.match(entry)[:ruleId])
              end
            end
            event.set('secRuleIds', secRuleIds)
          "
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Get rid of fields that we don't need anymore
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    mutate {
      remove_field => [ "message", "raw_responseHeaders", "raw_requestHeaders", "rawSectionZ"]
    }
  }
}
output {

  # turn this off when ready to run in a 
  # real prod environment and get rid of the 
  # "-v" flag when starting logstash
  stdout { codec => rubydebug }
  
}
##########################################################
##########################################################
#
# Example Modsecurity audit log ingestor
# configuration for Logstash
#
# @author bitsofinfo.g[at]gmail.com
# built/tested w logstash v1.3.x line
#
#
# @see http://logstash.net/
# @see https://github.com/SpiderLabs/ModSecurity/wiki/ModSecurity-2-Data-Formats
# @see http://bitsofinfo.wordpress.com/2013/09/19/logstash-for-modsecurity-audit-logs/
#
# @license http://www.apache.org/licenses/LICENSE-2.0
#
# @notes NOTE: this is not perfect and I am no Ruby expert
#        however this worked when processing quite a bit of
#        high volume mod-sec logs with lots of different
#        variations in what A-K sections were and were not
#        present. At a minimum its a good starting point
#        to start tackling a complex log format.
#
# Be careful w/ the custom ruby filter blocks and be aware
# of https://logstash.jira.com/browse/LOGSTASH-1375
#
# This config file for whatever reason will not run
# if you try to add the "-- web" option onto the logstash
# flat jar. This has been reported to the developers.
# Recommend you run this without the "-- web" option and just
# hook up Kibana separately.
#
# Enable the "-v" verbose option when starting logstash
# to aid in debugging things. Disable the "-v" option
# when running in real/non-debug environment
#
#
##########################################################
##########################################################
input {

  stdin {
    type => "mod_security_alert"

    codec => multiline {
      pattern => "^--[a-fA-F0-9]{8}-Z--$"
      negate => true
      what => next
    }
  }

}
input {
  file {
    # IMPORTANT! set this correctly to the charset
    # that your server writes these log files in
    path => "/path/to/your/modsec/audit/logs/*.log"
    type => "mod_security_alert"

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # merge all modsec events for a given entity into the same event.
    # so essentially the modsec -Z marker is used as the splitter
    # which is the end of each modsec logical event in the logfile
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    codec => multiline {
      charset => "US-ASCII"
      pattern => "^--[a-fA-F0-9]{8}-Z--$"
      negate => true
      what => next
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Due to the complexity of the collapsed single string
    # we get from multiline and the variance of exactly
    # which modsec sections (A-K) may or may not be in each
    # log entry, we run some custom ruby code that will
    # split on each modsec "section" and store each found in
    # new fields named "rawSection[A-K]" as appropriate, the value
    # of each of these fields contains the raw un-parsed data
    # from that modsec section. Sections that are non-existant
    # will not have a key in "fields"
    #
    # A bit long and crazy yes, but after spending many hours
    # just doing this w/ grok patterns, this ended up being the
    # most reliable way to break up this in-consistent format into
    # more usable blocks
    #
    # @see https://github.com/SpiderLabs/ModSecurity/wiki/ModSecurity-2-Data-Formats
    #
    # READ the above to get a good understanding of the sections
    # and which ones can actively contain data depending on your modsec
    # version and environment!
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    ruby {
      code => "
          if !event.get('message').nil?
              modSecSectionData = event.get('message').split(/(?:--[a-fA-F0-9]{8}-([A-Z])--)/)
              modSecSectionData.shift
              for i in 0..((modSecSectionData.length-1)/2)
                  sectionName = 'rawSection'.concat(modSecSectionData.shift)
                  sectionData = modSecSectionData.shift
                  sectionName = sectionName.strip
                  if !sectionData.nil?
                      sectionData = sectionData.strip
                  end
                  event.set(sectionName, sectionData)
              end
          end
        "
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out fields from Section A (general event basics)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    grok {
      match => {
        "rawSectionA" => "\[(?<modsec_timestamp>%{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} [-\+]{1,2}%{INT})\] %{DATA:uniqueId} %{IP:sourceIp} %{INT:sourcePort} %{IP:destIp} %{INT:destPort}"
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out fields from Section B (request related line 1)
    # note line one could be garbage OR adhere to the
    # httpMethod [space] uri [space] protocol pattern
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # if a legit line... normal http request
    if [rawSectionB] =~ /.+/ {
      grok {
        match => {
          "rawSectionB" => [  "(?m)^%{DATA:httpMethod}\s(?<requestedUri>\S+)\s(?<incomingProtocol>[^\n]+)(?:\n(?<raw_requestHeaders>.+)?)?$",
                              "(?<httpMethod>^(.*)$)" ]
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Convert raw request headers into a key/value
    # pair map
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [raw_requestHeaders] =~ /.+/ {
      kv {
        source => "raw_requestHeaders"
        field_split => "\n"
        value_split => ":"
        target => "requestHeaders"
      }


      # trim leading/trailing hack  @see https://logstash.jira.com/browse/LOGSTASH-1369
      ruby {
        code => "
            requestHeaders = event.get('requestHeaders').to_hash
            requestHeaders.each { |k, v|
              if !v.nil? and v.is_a? String
                requestHeaders[k] = v.strip
              end
            }
          "
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Example of looking for a specific Cookie and promoting
    # it to a first class field
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [raw_requestHeaders] =~ /Cookie/ and [raw_requestHeaders] =~ /myCookie=.+\b/ {

      grok {
        match => {
          "raw_requestHeaders" => "(?<myCookie>myCookie[^; \s]+)"
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Promote real request IP to a field if it exists
    # in the request headers section
    #
    # NOTE this is an example of promoting a custom header to a first
    # class field that might be set by a app firewall or other
    # upstream proxy
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [raw_requestHeaders] =~ /X-Forwarded-For:/ {

      grok {
        match => {
          "raw_requestHeaders" => "X-Forwarded-For: %{IPORHOST:XForwardedFor}"
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Example of splitting all Cookies from the requestHeader Cookie
    # and promoting it to a first class field
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [requestHeaders][Cookie] =~ /.+/ {
        kv {
            source => "[requestHeaders][Cookie]"
            field_split => "; "
            value_split => "="
            target => "requestCookies"
        }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out fields from Section C (post data)
    # this is not always present
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionC] =~ /.+/ {
      mutate {
          add_field => { "requestBody" => "%{rawSectionC}" }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section D (intended response headers)
    # this section is NOT IMPLEMENTED by ModSecurity
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    #if [rawSectionD] =~ /.+/ {
    #  # you can deal w/ this if you want to here...
    #}
  }
}
filter {
  if [type] == "mod_security_alert" {
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section E (intended response data)
    # this is not always present
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionE] =~ /.+/ {
      # you can deal w/ this if you want to here...
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out server protocol/HTTP status from Section F (response related, line 1)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionF] =~ /.+/ {

      grok {
        match => {
          "rawSectionF" => "(?m)^(?<serverProtocol>.+?)\s(?<responseStatus>[^\n]+)(\n(?<raw_responseHeaders>.+)?)?$"
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse out response headers from Section F (response headers, lines 2+)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # only if the server responded...WITH headers...
    if [rawSectionF] =~ /(.+?)\s(.+)\n{1}/ {

      grok {
        match => {
          "rawSectionF" => ".+?\n(?m)(?<raw_responseHeaders>.+)"
        }
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Convert raw response headers into a key/value
    # pair map
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [raw_responseHeaders] =~ /.+/ {
      kv {
        source => "raw_responseHeaders"
        field_split => "\n"
        value_split => ":"
        target => "responseHeaders"
      }

      # trim leading/trailing hack  @see https://logstash.jira.com/browse/LOGSTASH-1369
      ruby {
        code => "
            responseHeaders = event.get('responseHeaders').to_hash
            responseHeaders.each { |k, v|
              if !v.nil? and v.is_a? String
                responseHeaders[k] = v.strip
              end
            }
          "
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section G (response body)
    # this section is NOT IMPLEMENTED by ModSecurity
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    #if [rawSectionG] =~ /.+/ {
    #  # you can deal w/ this if you want to here...
    #}
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Explode all "Messages" from sectionH to first
    # class objects w/ properties and store in an array
    # called "auditLogTrailerMessages"
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionH] =~ /.+/ {

      # build the auditlog trailer messages
      ruby {
        code => "
            def extractVal(pattern, fromString, storeResultIn, underKeyName, multiValues=false)
              if multiValues
                result = fromString.scan(pattern)
                if !result.empty?
                  storeResultIn[underKeyName] = result.flatten
                end
              else
                result = pattern.match(fromString)
                if !result.nil?
                  storeResultIn[underKeyName] = result[1]
                end
              end
            end

            auditLogTrailerMessages = Array.new()
            trailer_array = event.get('rawSectionH').split(/\n/)
            trailer_array.each do |entry|
              if entry.match(/^Message: /)
                msg = Hash.new()
                extractVal(/Message: (.+)\s($|(\s*\[file))/, entry, msg, 'info')
                extractVal(/\[file \"(.*?)\"\]/, entry, msg, 'file')
                extractVal(/\[line \"(.*?)\"\]/, entry, msg, 'line')
                extractVal(/\[id \"(.*?)\"\]/, entry, msg, 'id')
                extractVal(/\[msg \"(.*?)\"\]/, entry, msg, 'msg')
                extractVal(/\[severity \"(.*?)\"\]/, entry, msg, 'severity')
                extractVal(/\[data \"(.*?)\"\]/, entry, msg, 'data')
                extractVal(/\[tag \"(.*?)\"\]/, entry, msg, 'tag')
                auditLogTrailerMessages.push(msg)
              end
            end

            event.set('auditLogTrailerMessages', auditLogTrailerMessages)
          "
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Convert section H into a key/value
    # pair map called "auditLogTrailer"
    # delete the 'Message' sub-key and replace with 'auditLogTrailerMessages'
    # built in the previous section under key 'messages', then
    # delete auditLogTrailerMessages
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionH] =~ /.+/ {
      # For 2.9.1+ compatibility
      mutate {
        # This works for most things, but if the error has things like REQUEST_HEADERS:Referer in it, it can be problematic.
      # gsub => [ "rawSectionH", 'ModSecurity:', 'ModSecurity' ]
        # Alternately, just drop "Apache-Error:" from rawSectionH.
        gsub => [ "rawSectionH", '^Apache-Error:.*', '' ]
      }
      kv {
        source => "rawSectionH"
        field_split => "\n"
        value_split => ":"
        target => "auditLogTrailer"
      }

      # trim leading/trailing hack  @see https://logstash.jira.com/browse/LOGSTASH-1369
      ruby {
        code => "
            auditLogTrailer = event.get('auditLogTrailer').to_hash
            auditLogTrailerMessages = event.get('auditLogTrailerMessages')
            auditLogTrailer.each { |k, v|
              if !v.nil? and v.is_a? String
                auditLogTrailer[k] = v.strip
              end
            }
            auditLogTrailer.delete('Message')
            auditLogTrailer['messages'] = auditLogTrailerMessages

            event.set('auditLogTrailer', auditLogTrailer)
          "
      }

      mutate {
        remove_field => ['auditLogTrailerMessages']
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Promote raw "stopwatch" in section H
    # to a real date. The value is in microseconds
    # since epoch (convert to seconds) then
    # run through logstashes' routine. The result
    # of this is that the logstash @timestamp is converted
    # to be the modsec stopwatch timestamp value. We
    # also retain the milliseconds and seconds fields
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    grok {
      match => {
        "rawSectionH" => "Stopwatch: %{WORD:event_date_microseconds}"
      }
    }

    mutate {
      convert => [ "event_date_microseconds", "float" ]
    }

    # micro -> milli
    ruby {
      code => "
          event_date_milliseconds = (event.get('event_date_microseconds') / 1000.0)
          event.set('event_date_milliseconds', event_date_milliseconds)
        "
    }

    # milli -> seconds
    ruby {
      code => "
          event_date_seconds = (event.get('event_date_milliseconds') / 1000.0)
          event.set('event_date_seconds', event_date_seconds)
        "
    }

    # NOTE!, this forces the event's @timestamp to be = to the stopwatch value
    date {
      match => [ "event_date_seconds", "UNIX" ]
      timezone => "GMT"
    }

    # a second copy of a iso8601 date
    ruby {
      code => "
          event.set('event_timestamp', (Time.at(event.get('event_date_seconds')).gmtime).iso8601(3))
        "
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Create a new field for the real requestor
    # ip address containing the GEOIP info
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    geoip {
      # does need XForwardedFor from 2029_filter_section_b_example_header_X-Forwarded-For.conf
      source => "XForwardedFor"
      target => "XForwardedFor-GEOIP"
    }

    geoip {
      source => "sourceIP"
      target => "sourceIP-GEOIP"
    }

    # Optional, if not fixed: massage values to UTF-8... hack  @see https://logstash.jira.com/browse/LOGSTASH-1372
    # convert Strings to UTF-8, leave as-is otherwise
    #ruby {
    #  code => "
    #      geoip = event.get('XForwardedFor-GEOIP').to_hash
    #      if !geoip.nil?
    #        newgeoip = Hash.new()
    #        geoip.each do |key,value|
    #          if !value.nil? and value.is_a? String
    #            newgeoip[key] = value.encode('UTF-8')
    #          else
    #            newgeoip[key] = value
    #          end
    #        end
    #        event.set('XForwardedFor-GEOIP', newgeoip)
    #      end
    #    "
    #}
  }
}
filter {

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Proceed to extract all distinct "severities"
  # and store them in a top-level "modsecSeverities" array
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  if [rawSectionH] =~ /.+/ {

    # extract distinct severities from the messages built in 2080_filter_section_h_parse_messages_to_auditLogTrailerMessages.conf
    ruby {
      code => "
          modsecSeverities = Set.new
          trailerMsgs = event.get('auditLogTrailer[messages]')
          trailerMsgs.each {|m|
            if m.key?('severity')
              modsecSeverities.add(m['severity'])
            end
          }
          event.set('modsecSeverities', modsecSeverities.to_a)
        "
    }
  }

}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section I (reduced multipart request body)
    # this is not always present
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionI] =~ /.+/ {
      # you can deal w/ this if you want to here...
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Optionally deal w/ Section J (multipart files information)
    # this section is NOT IMPLEMENTED by ModSecurity
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    #if [rawSectionJ] =~ /.+/ {
    #  # you can deal w/ this if you want to here...
    #}
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Convert section K into an array
    # and rename it to "matchedRules"
    # also create an array of just the
    # secRuleIds that were located in
    # sectionK
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if [rawSectionK] =~ /.+/ {

      # hack.. @see https://logstash.jira.com/browse/LOGSTASH-1331
      mutate {
        gsub => [ "rawSectionK", "\n", "~" ]
        split => [ "rawSectionK" , "~" ]
      }

      mutate {
        rename => [ "rawSectionK", "matchedRules"]
      }

      ruby {
        code => "
            secRuleIds = Array.new()
            matchedRules_array = event.get('matchedRules').to_hash
            matchedRules_array.each do |entry|
              if entry.match(/^SecRule /) and entry.match(/,id:/)
                secRuleIds.push(/,id:(?<ruleId>\d+)/.match(entry)[:ruleId])
              end
            end
            event.set('secRuleIds', secRuleIds)
          "
      }
    }
  }
}
filter {
  if [type] == "mod_security_alert" {

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Get rid of fields that we don't need anymore
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    mutate {
      remove_field => [ "message", "raw_responseHeaders", "raw_requestHeaders", "rawSectionZ"]
    }
  }
}
output {

if [type] == "mod_security_alert" {

elasticsearch  {
     user => "elastic"
     password => "changeme"
     hosts => "elasticsearch:9200"
     index => "logstash_mod_security_alert-%{+YYYY.MM.dd}"
     template_name => "logstash_mod_security_alert"
     template => "/etc/logstash/template_mapping/rocaweb/logstash_mod_security_alert.json"
     }
}

stdout { codec => rubydebug }
  
}
